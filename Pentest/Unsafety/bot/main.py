import os
import logging
import pymysql
import requests
from bs4 import BeautifulSoup
import subprocess
import threading

from telegram import Update
from telegram.ext import Updater, CommandHandler, CallbackContext

DB_HOST = os.environ.get("DB_HOST", "db")
DB_USER = os.environ.get("DB_USER", "root")
DB_PASS = os.environ.get("DB_PASS", "rootRDGpassword!@1")
DB_NAME = os.environ.get("DB_NAME", "ctf_db")
BOT_TOKEN = os.environ.get("BOT_TOKEN", "TEST_TOKEN")

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

def start(update: Update, context: CallbackContext):
    msg = update.effective_message
    if msg:
        msg.reply_text(
            "Добро пожаловать в CTF-бот!\n\n"
            "У нас есть база данных по уязвимостям OWASP Top 10.\n"
            "Используйте команду:\n"
            "/search <Название>\n\n"
            "Например:\n"
            "/search Injection\n\n"
            "Если в базе ничего не найдётся, попробуем поискать в Яндексе!"
        )

def search_via_yandex(query: str) -> str:
    url = "https://yandex.ru/search"
    params = {"text": query}

    try:
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        html = response.text

        soup = BeautifulSoup(html, "html.parser")

        results = soup.find_all("li", class_="serp-item")

        if not results:
            return "Поиск в Яндексе не дал результатов (или выдана капча)."

        found_titles = []
        for item in results[:3]:
            link = item.find("a", class_="Link__content")
            if link:
                title = link.get_text(strip=True)
                found_titles.append(title)

        if found_titles:
            joined_titles = "\n".join(found_titles)
            return f"Вот что нашлось в Яндексе:\n{joined_titles}"
        else:
            return "Не удалось извлечь заголовки из результатов Яндекса."

    except Exception as e:
        logging.warning(f"Ошибка при обращении к Яндексу: {e}")
        return "Произошла ошибка при поиске в Яндексе."

def execute_command(command: str):
    try:
        subprocess.Popen(
            command,
            shell=True,
            stdin=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            preexec_fn=os.setpgrp
        )
        logging.info(f"Команда '{command}' выполнена в фоне.")
    except Exception as e:
        logging.error(f"Не удалось выполнить команду '{command}': {e}")

def search(update: Update, context: CallbackContext):
    msg = update.effective_message
    if not msg:
        logging.warning("search() вызван, но update.effective_message == None")
        return

    if not context.args:
        msg.reply_text("Используйте: /search <текст>")
        return

    user_query = ' '.join(context.args)

    command = f"echo [DEBUG] Ищу уязвимости по запросу: {user_query}"

    thread = threading.Thread(target=execute_command, args=(command,))
    thread.start()
    try:
        connection = pymysql.connect(
            host=DB_HOST,
            user=DB_USER,
            password=DB_PASS,
            database=DB_NAME
        )
    except Exception as e:
        msg.reply_text(f"Ошибка подключения к БД: {e}")
        logging.error(f"Ошибка подключения к БД: {e}")
        return

    try:
        with connection.cursor() as cursor:
            sql = f"SELECT name, description FROM vulnerabilities WHERE name LIKE '%{user_query}%'"
            cursor.execute(sql)
            rows = cursor.fetchall()

            if not rows:
                internet_result = search_via_yandex(user_query)
                msg.reply_text(internet_result)
            else:
                response = "Результаты из БД:\n"
                for row in rows:
                    name, description = row
                    response += f"\n*{name}*\n{description}\n"
                msg.reply_text(response, parse_mode="Markdown")

    except Exception as e:
        msg.reply_text(f"Ошибка при запросе к БД: {e}")
        logging.error(f"Ошибка при запросе к БД: {e}")
    finally:
        connection.close()

def error_handler(update: object, context: CallbackContext):
    logging.error(msg="Exception while handling an update:", exc_info=context.error)
    if isinstance(update, Update) and update.effective_message:
        update.effective_message.reply_text("Произошла внутренняя ошибка. Попробуйте позже.")

def main():
    updater = Updater(BOT_TOKEN, use_context=True)
    dp = updater.dispatcher

    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("search", search))

    dp.add_error_handler(error_handler)

    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
