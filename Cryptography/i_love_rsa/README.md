# i love rsa

# Описание

|Название|Сложность|Автор|
|------|-----|-------|
|I Love RSA|Easy|[@sergbyand](https://sergbyand) |

## Условия задачи
Дана система RSA с:
- Общим показателем `e = 5` для всех пользователей
- Разными модулями `n₁, n₂, ..., n₅`
- Разными зашифрованными сообщениями:
  ```
  cᵢ ≡ mᵢ⁵ (mod nᵢ) для i = 1..5
  ```

## Особенность сообщений
Сообщения связаны соотношением:
```
m₅ = 256·m₄ = 256²·m₃ = 256³·m₂ = 256⁴·m₁
```

## Алгоритм атаки

1. **Модификация шифротекстов** (используя гомоморфные свойства):
   ```
   cᵢ' ≡ cᵢ·(256⁵⁻ⁱ)⁵ mod nᵢ
   ```
   Теперь все `cᵢ'` соответствуют шифрованию `m₅`

2. **Китайская теорема об остатках**:
   ```
   N = ∏ nᵢ
   Находим C такое, что:
   C ≡ cᵢ' mod nᵢ для всех i
   ```

3. **Извлечение корня**:
   ```
   m₅ = ⁵√C
   ```

## Реализация на Python

```python
from Cryptodome.Util.number import long_to_bytes

# Дано
N = [5865...859, 9651...597, 7300...351, 6442...303, 8601...517]  # n_i
C = [1022...186, 8302...094, 6630...783, 2421...089, 3047...966]  # c_i

def KTO(x, m):
    """Китайская теорема об остатках"""
    M = 1
    for mi in m:
        M *= mi
    X = 0
    for i in range(len(x)):
        Mi = M // m[i] 
        X = (X + x[i] * Mi * pow(Mi, -1, m[i])) % M
    return X

def sqrt5(x):
    """Извлечение корня 5-й степени бинарным поиском"""
    a, b = 0, x
    while b - a > 1:
        s = (a + b) >> 1
        if s**5 <= x:
            a = s
        else:
            b = s
    return a

def main():
    e = 5
    # Модифицируем шифротексты
    for i in range(4):
        C[i] = (C[i] * pow(256, e*(4-i), N[i])) % N[i]
    
    # Применяем КТО
    x = KTO(C, N)
    
    # Получаем флаг
    flag = long_to_bytes(sqrt5(x))
    print(flag)

if __name__ == "__main__":
    main()
```
  
# Ответ
rdg{Y3s_h0w_mUch_Can_y0U_m3sS_w1tH_RSA}
