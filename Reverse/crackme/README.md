# CrackMe

## Описание 
| Название | Сложность | TLDR | Автор |
|------|-----|-------|--------|
| CrackMe | Medium | python decompilation with RSA  |[@maxhays](https://t.me/maxhays) |

# Решение

Разбираем Pyinstaller, достаём главный исполняемый модуль. При помощи pycdc, uncompyle6 или decompyle3

<img width="303" alt="изображение" src="https://github.com/user-attachments/assets/b025f875-4fff-4ef2-b058-d4163a1c27b0" />

Видим, что у нас идёт проверка пароля. При помощи функции decrypt, которая на самом деле является xor шифрованием и вводит нас в заблуждение своим названием.

Расшифрованный пароль «RDGCTFPASSpaaaaaasssssssspaaaasssssssssssss» позволяет нам попасть во вторую стадию. Восстанавливаем исходники второй стадии.

<img width="371" alt="изображение" src="https://github.com/user-attachments/assets/6758256a-0b35-4a2f-9d01-0fda3c39044b" />

Во второй стадии код также зашифрован xor’ом. Правильный ключ позволяет получить правильный исполняемый код. Пробуем его перебрать, проверяя хэш кода. Ключ P@SS.

Переходим к третьей стадии.

Восстановленная финальная стадия является реализацией алгоритма RSA с уязвимостью. 

Уязвимость в том, что `n = p*q = p*2^(L // 2) + a`, где `L` - это длина в битах числа `n`, `a` - какое-то размера `L // 2` бит

И получается, что старшие биты - это и есть простое число p. Таким образом создан бэкдор, что зная n можно найти p. 

Отдаём это все криптографу, прогоняем через RSACTFTool и получаем флаг.

## Flag
rdg{pyth0n_m@tr3shk@}
